import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import minimize

plt.rcParams['font.sans-serif'] = ['SimHei']  
plt.rcParams['axes.unicode_minus'] = False    


class FourthOrderCenter:
    def __init__(self):
        #使用4阶中心差分格式 [f(j-2)-8f(j-1)+8f(j+1)-f(j+2)]/12△x,故对应系数如下
        self.coefficients=np.array([1/12,-2/3,0,2/3,-1/12])

        #题目要求：6点格式的系数 初始化
        #a1*f(j-3)+a2*f(j-2)+a3*f(j-1)+a4*f(j)+a5*f(j+1)+a6*f(j+2)
        self.a=np.zeros(6)

    def set_coefficients(self): #设置系数
        self.a=np.array([1/12,-2/3,0,2/3,-1/12,0])

    def set_coefficients_with_one_free(self,beta):
        """
        使用第三讲的优化技术，4阶精度，Taylor展开有5个方程
        6个未知数，故有1个自由参数
        f(x-3Δx) = f(x) - 3Δx f'(x) + (3Δx)²/2! f''(x) - (3Δx)³/3! f'''(x) + (3Δx)⁴/4! f''''(x) + O(Δx⁵)
        f(x-2Δx) = f(x) - 2Δx f'(x) + (2Δx)²/2! f''(x) - (2Δx)³/3! f'''(x) + (2Δx)⁴/4! f''''(x) + O(Δx⁵)
        f(x-Δx) = f(x) - Δx f'(x) + (Δx)²/2! f''(x) - (Δx)³/3! f'''(x) + (Δx)⁴/4! f''''(x) + O(Δx⁵)
        f(x) = f(x)
        f(x+Δx) = f(x) + Δx f'(x) + (Δx)²/2! f''(x) + (Δx)³/3! f'''(x) + (Δx)⁴/4! f''''(x) + O(Δx⁵)
        f(x+2Δx) = f(x) + 2Δx f'(x) + (2Δx)²/2! f''(x) + (2Δx)³/3! f'''(x) + (2Δx)⁴/4! f''''(x) + O(Δx⁵)
        a₁ + a₂ + a₃ + a₄ + a₅ + a₆ = 0
        -3a₁ - 2a₂ - a₃ + 0 + a₅ + 2a₆ = 1
        9a₁ + 4a₂ + a₃ + 0 + a₅ + 4a₆ = 0
        -27a₁ - 8a₂ - a₃ + 0 + a₅ + 8a₆ = 0
        81a₁ + 16a₂ + a₃ + 0 + a₅ + 16a₆ = 0
        """
        A=np.array([
            [1,1,1,1,1,1],
            [-3,-2,-1,0,1,2],
            [9/2,2,1/2,0,1/2,2],
            [-27/6,-8/6,-1/6,0,1/6,8/6],
            [81/24,16/24,1/24,0,1/24,16/24]
        ])
        #目标向量[0,1,0,0,0]
        B=np.array([0,1,0,0,0])

        #A × [a₁, a₂, a₃, a₄, a₅, a₆]ᵀ = b
        #自由参数beta，令a6=beta
        A_a1_a5=A[:,:5]
        B_a6=B-beta*A[:,5]
        a_a1_a5=np.linalg.solve(A_a1_a5, B_a6) #求解5×5线性系统
        self.a = np.concatenate([a_a1_a5, [beta]]) #组合解

    def fourier_analysis(self, alpha):
        """
        傅里叶分析计算修正波数
        """
        k_f = 0.0j
        for i, coe in enumerate(self.a):
            n = i - 3
            k_f += coe * np.exp(1j * n * alpha)
        return k_f.real, k_f.imag

    def spatial_derivative(self, u, dx):
        """
        计算空间导数 du/dx
        使用6点差分格式，考虑周期性边界条件
        """
        N = len(u)
        du_dx = np.zeros(N)

        # 扩展数组以处理边界条件（周期性）
        u_extended = np.concatenate([u[-3:], u, u[:3]])

        for i in range(3, N + 3):
            # 使用6点格式计算导数
            du_dx_i = 0
            for j in range(6):
                du_dx_i += self.a[j] * u_extended[i + j - 3]
            du_dx[i - 3] = du_dx_i / dx

        return du_dx


def rk3_step(u, dt, dx, scheme):
    """
    3步Runge-Kutta时间推进
    方程: du/dt + du/dx = 0
    """
    # 第一步
    L1 = -scheme.spatial_derivative(u, dx)
    u1 = u + dt * L1

    # 第二步
    L2 = -scheme.spatial_derivative(u1, dx)
    u2 = (3 / 4) * u + (1 / 4) * u1 + (1 / 4) * dt * L2

    # 第三步
    L3 = -scheme.spatial_derivative(u2, dx)
    u_new = (1 / 3) * u + (2 / 3) * u2 + (2 / 3) * dt * L3

    return u_new
def plot_fourier_analysis(scheme, beta_values, alpha_range):
    """绘制傅里叶分析结果"""
    plt.figure(figsize=(12, 5))

    # 绘制不同beta值的曲线
    for beta in beta_values:
        scheme.set_coefficients_with_one_free(beta)

        kr_values = []
        ki_values = []

        for alpha in alpha_range:
            kr, ki = scheme.fourier_analysis(alpha)
            kr_values.append(kr)
            ki_values.append(ki)

        # kr
        plt.subplot(1, 2, 1)
        plt.plot(alpha_range, kr_values, label=f'a6={beta:.2f}')

        # ki
        plt.subplot(1, 2, 2)
        plt.plot(alpha_range, ki_values, label=f'a6={beta:.2f}')

    # kr
    plt.subplot(1, 2, 1)
    plt.plot(alpha_range, np.zeros_like(alpha_range), 'k--', label='标准线: kr=0', linewidth=1.5)
    plt.xlabel(r'$\alpha$')
    plt.ylabel(r'kr')
    plt.title('傅里叶分析kr')
    plt.legend()
    plt.grid(True)

    # ki
    plt.subplot(1, 2, 2)
    plt.plot(alpha_range, alpha_range, 'k--', label='标准线: ki=α', linewidth=1.5)
    plt.xlabel(r'$\alpha$')
    plt.ylabel(r'ki')
    plt.title('傅里叶分析ki')
    plt.legend()
    plt.grid(True)

    plt.tight_layout()
    plt.show()


def custom_error_objective(beta, error=0.05, penalty_weight=1000):
    """
    自定义误差目标函数：寻找使α* - k_i(α*) ≤ error的最大α*
    """
    scheme = FourthOrderCenter()
    beta_scalar = beta[0] if hasattr(beta, '__len__') else beta

    scheme.set_coefficients_with_one_free(beta_scalar)

    # 定义波数范围
    alpha_range = np.linspace(0, np.pi, 500)

    # 寻找满足 α - ki(α) ≤ error 的最大α*
    alpha_star = 0
    max_overshoot = 0

    for i, alpha in enumerate(alpha_range):
        kr, ki = scheme.fourier_analysis(alpha)
        # 检查是否超出标准线
        if ki > alpha+1e-10:
            overshoot = ki-alpha
            max_overshoot = max(max_overshoot, overshoot)

        # 检查是否满足误差条件
        if alpha-ki <= error:
            alpha_star = alpha
        else:
            # 一旦不满足条件，停止搜索
            break

    # 如果存在超出标准线的情况，给予惩罚
    overshoot_penalty = penalty_weight * max_overshoot

    # 目标函数：最小化 (π - α*) + 超出惩罚
    # 我们希望最大化α*，所以最小化(π - α*)
    objective_value = (np.pi - alpha_star) + overshoot_penalty

    return objective_value


def adaptive_error_optimizer(scheme, initial_error, min_error, step_size):
    """
    自适应误差优化器：逐步减小误差阈值，寻找最优a6
    """
    error = initial_error
    best_beta = 0.0
    best_alpha_star = 0

    print("开始自适应误差优化...")

    while error>= min_error:
        # 使用当前误差阈值进行优化
        result = minimize(
            lambda beta: custom_error_objective(beta, error),  # 使用正确的变量名
            0.0,
            method='Nelder-Mead',
            options={'maxiter': 500, 'disp': False}
        )

        if result.success:
            beta_candidate = result.x[0]

            # 计算对应的α*
            scheme.set_coefficients_with_one_free(beta_candidate)
            alpha_range = np.linspace(0, np.pi, 500)
            alpha_star_candidate = 0

            for alpha in alpha_range:
                kr, ki = scheme.fourier_analysis(alpha)
                if alpha - ki <= error:
                    alpha_star_candidate = alpha
                else:
                    break

            # 更新最佳结果
            if alpha_star_candidate > best_alpha_star:
                best_alpha_star = alpha_star_candidate
                best_beta = beta_candidate

        # 减小误差阈值
        error -= step_size

    print(f"\n自适应优化完成:")
    print(f"最优a6: {best_beta:.8f}")
    print(f"最大α*: {best_alpha_star:.4f}")
    print(f"error: {error:.4f}")

    return best_beta, best_alpha_star


def optimize_and_plot():
    """执行优化并绘制结果"""
    scheme = FourthOrderCenter()

    # 定义不同的beta值用于比较
    beta_values = [-0.01, -0.05, -0.03, -0.07]

    # 定义alpha范围：从0到π
    alpha_range = np.linspace(0, np.pi, 100)

    # 绘制不同a6值的傅里叶分析图
    plot_fourier_analysis(scheme, beta_values, alpha_range)

    # 使用自适应误差优化器
    optimal_beta, best_alpha_star= adaptive_error_optimizer(
        scheme,
        initial_error=0.05,
        min_error=0.03,
        step_size=0.001
    )

    # 绘制最优a6值的结果
    plt.figure(figsize=(12, 5))

    # 计算最优a6值的曲线
    alpha_range_detailed = np.linspace(0, np.pi, 500)
    kr_optimal = []
    ki_optimal = []

    for alpha in alpha_range_detailed:
        kr, ki = scheme.fourier_analysis(alpha)
        kr_optimal.append(kr)
        ki_optimal.append(ki)

    # kr - 添加标准线kr=0
    plt.subplot(1, 2, 1)
    plt.plot(alpha_range_detailed, kr_optimal, 'r-', label=f'最优 a6={optimal_beta:.8f}', linewidth=2)
    plt.plot(alpha_range_detailed, np.zeros_like(alpha_range_detailed), 'k--', label='标准线: kr=0', linewidth=1.5)
    plt.xlabel(r'$\alpha$')
    plt.ylabel('kr')
    plt.title('最优a6的修正波数kr')
    plt.legend()
    plt.grid(True)

    # ki - 添加标准线ki=α
    plt.subplot(1, 2, 2)
    plt.plot(alpha_range_detailed, ki_optimal, 'r-', label=f'最优 a6={optimal_beta:.8f}', linewidth=2)
    plt.plot(alpha_range_detailed, alpha_range_detailed, 'k--', label='标准线: ki=α', linewidth=1.5)

    plt.xlabel(r'$\alpha$')
    plt.ylabel('ki')
    plt.title('最优a6的修正波数ki')
    plt.legend()
    plt.grid(True)

    plt.tight_layout()
    plt.show()

def numerical_verification(scheme, beta, dt=0.01, show_plots=True):
    """
    数值验证函数
    """
    # 参数设置
    L = 2 * np.pi  # 计算域长度
    N = 20  # 网格点数
    dx = L / N  # 网格间距

    # 时间设置
    t_end_1 = 20.0
    t_end_2 = 50.0

    # 设置系数
    scheme.set_coefficients_with_one_free(beta)

    # 网格点
    x = np.linspace(0, L, N, endpoint=False)

    # 初始条件
    u0 = np.sin(x)
    u_numerical_1 = u0.copy()
    u_numerical_2 = u0.copy()

    # 时间推进到 t=20
    n_steps_1 = int(t_end_1 / dt)
    for step in range(n_steps_1):
        u_numerical_1 = rk3_step(u_numerical_1, dt, dx, scheme)

    # 时间推进到 t=50
    n_steps_2 = int(t_end_2 / dt)
    for step in range(n_steps_2):
        u_numerical_2 = rk3_step(u_numerical_2, dt, dx, scheme)

    # 精确解
    u_exact_1 = np.sin(x - t_end_1)  # 精确解: u(x,t) = sin(x-t)
    u_exact_2 = np.sin(x - t_end_2)

    # 计算L2误差
    error_1 = np.sqrt(np.sum((u_numerical_1 - u_exact_1) ** 2) / N)
    error_2 = np.sqrt(np.sum((u_numerical_2 - u_exact_2) ** 2) / N)

    print(f"beta = {beta:.6f}")
    print(f"t=20 时刻的L2误差: {error_1:.6e}")
    print(f"t=50 时刻的L2误差: {error_2:.6e}")

    if show_plots:
        # 绘制结果
        plt.figure(figsize=(15, 6))

        # t=20 时刻
        plt.subplot(1, 2, 1)
        plt.plot(x, u_exact_1, 'b-', linewidth=2, label='精确解')
        plt.plot(x, u_numerical_1, 'ro', markersize=4, label='数值解')
        plt.xlabel('x')
        plt.ylabel('u(x,t)')
        plt.title(f't=20时刻 (beta={beta:.6f})\nL2误差: {error_1:.2e}')
        plt.legend()
        plt.grid(True)

        # t=50 时刻
        plt.subplot(1, 2, 2)
        plt.plot(x, u_exact_2, 'b-', linewidth=2, label='精确解')
        plt.plot(x, u_numerical_2, 'ro', markersize=4, label='数值解')
        plt.xlabel('x')
        plt.ylabel('u(x,t)')
        plt.title(f't=50时刻 (beta={beta:.6f})\nL2误差: {error_2:.2e}')
        plt.legend()
        plt.grid(True)

        plt.tight_layout()
        plt.show()

    return error_1, error_2


def compare_different_betas():
    """
    比较不同a6值的数值表现
    """
    scheme = FourthOrderCenter()

    # 测试不同的beta值
    beta_values = [-0.01, -0.03, -0.05, -0.07]

    errors_t20 = []
    errors_t50 = []

    print("=" * 60)
    print("不同a6值的数值验证结果")
    print("=" * 60)

    for i, beta in enumerate(beta_values):
        print(f"\n--- 测试 {i + 1}: a6 = {beta} ---")
        error_20, error_50 = numerical_verification(scheme, beta, show_plots=True)
        errors_t20.append(error_20)
        errors_t50.append(error_50)

    # 绘制误差比较图
    plt.figure(figsize=(12, 5))

    plt.subplot(1, 2, 1)
    plt.plot(beta_values, errors_t20, 'bo-', linewidth=2, markersize=8)
    plt.xlabel('a6')
    plt.ylabel('L2误差')
    plt.title('t=20时刻不同beta值的L2误差')
    plt.grid(True)

    plt.subplot(1, 2, 2)
    plt.plot(beta_values, errors_t50, 'ro-', linewidth=2, markersize=8)
    plt.xlabel('a6')
    plt.ylabel('L2误差')
    plt.title('t=50时刻不同beta值的L2误差')
    plt.grid(True)

    plt.tight_layout()
    plt.show()

    # 找到最优的beta（最小误差）
    best_idx_20 = np.argmin(errors_t20)
    best_idx_50 = np.argmin(errors_t50)

    print(f"\n最优结果总结:")
    print(f"t=20时刻最优a6: {beta_values[best_idx_20]}, 最小误差: {errors_t20[best_idx_20]:.6e}")
    print(f"t=50时刻最优a6: {beta_values[best_idx_50]}, 最小误差: {errors_t50[best_idx_50]:.6e}")


def find_optimal_beta_numerically():
    """
    通过数值实验寻找最优beta
    """
    scheme = FourthOrderCenter()

    def objective_function(beta):
        """目标函数：最小化t=50时刻的L2误差"""
        error_20, error_50 = numerical_verification(scheme, beta[0], show_plots=False)
        return error_50

    # 在[-0.1, 0]范围内寻找最优beta
    result = minimize(objective_function, [-0.03], bounds=[(-0.1, 0)], method='L-BFGS-B')

    if result.success:
        optimal_beta = result.x[0]
        optimal_error_20, optimal_error_50 = numerical_verification(scheme, optimal_beta, show_plots=True)

        print(f"\n数值优化结果:")
        print(f"最优a6: {optimal_beta:.8f}")
        print(f"t=20时刻最优误差: {optimal_error_20:.6e}")
        print(f"t=50时刻最优误差: {optimal_error_50:.6e}")

        return optimal_beta
    else:
        print("优化失败")
        return None


# 主程序
if __name__ == "__main__":
    optimize_and_plot()
    print("开始数值验证...")

    # 方法1: 比较几个预设的beta值
    print("\n1. 比较不同a6值的数值表现")
    compare_different_betas()

    # 方法2: 数值优化寻找最优beta
    print("\n2. 数值优化寻找最优a6")
    optimal_beta = find_optimal_beta_numerically()

    if optimal_beta is not None:
        print(f"\n最终推荐的最优a6值: {optimal_beta:.8f}")

        # 用最优beta进行最终验证
        scheme = FourthOrderCenter()
        print("\n最终验证:")
        numerical_verification(scheme, optimal_beta, show_plots=True)
